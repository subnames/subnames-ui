// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Viem from "viem";
import * as Ens from "viem/ens";
import * as Constants from "./Constants.res.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__BigInt from "@rescript/core/src/Core__BigInt.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as OnChainOperationsCommon from "./OnChainOperationsCommon.res.mjs";

var baseRegistrarContract = {
  address: Constants.baseRegistrarContractAddress,
  abi: [
    {
      type: "function",
      name: "nameExpires",
      inputs: [{
          name: "id",
          type: "uint256"
        }],
      outputs: [{
          name: "expiry",
          type: "uint256"
        }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "safeTransferFrom",
      inputs: [
        {
          name: "from",
          type: "address"
        },
        {
          name: "to",
          type: "address"
        },
        {
          name: "tokenId",
          type: "uint256"
        }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "reclaim",
      inputs: [
        {
          name: "id",
          type: "uint256"
        },
        {
          name: "owner",
          type: "address"
        }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    }
  ]
};

var resolverContract = {
  address: Constants.resolverContractAddress,
  abi: [
    {
      inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }],
      name: "name",
      outputs: [{
          internalType: "string",
          name: "",
          type: "string"
        }],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "nodehash",
          type: "bytes32"
        },
        {
          internalType: "bytes[]",
          name: "data",
          type: "bytes[]"
        }
      ],
      name: "multicallWithNodeCheck",
      outputs: [{
          internalType: "bytes[]",
          name: "results",
          type: "bytes[]"
        }],
      stateMutability: "nonpayable",
      type: "function"
    }
  ]
};

var registryContract = {
  address: Constants.registryContractAddress,
  abi: [
    {
      type: "function",
      name: "recordExists",
      inputs: [{
          name: "node",
          type: "bytes32"
        }],
      outputs: [{
          name: "",
          type: "bool"
        }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "owner",
      inputs: [{
          name: "node",
          type: "bytes32"
        }],
      outputs: [{
          name: "",
          type: "address"
        }],
      stateMutability: "view"
    }
  ]
};

var controllerContract = {
  address: Constants.controllerContractAddress,
  abi: [
    {
      type: "function",
      name: "available",
      inputs: [{
          name: "name",
          type: "string"
        }],
      outputs: [{
          name: "",
          type: "bool"
        }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "registerPrice",
      inputs: [
        {
          name: "name",
          type: "string"
        },
        {
          name: "duration",
          type: "uint256"
        }
      ],
      outputs: [{
          name: "",
          type: "uint256"
        }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "rentPrice",
      inputs: [
        {
          name: "name",
          type: "string"
        },
        {
          name: "duration",
          type: "uint256"
        }
      ],
      outputs: [{
          name: "",
          type: "uint256"
        }],
      stateMutability: "view"
    }
  ],
  register: {
    inputs: [{
        components: [
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "duration",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "resolver",
            type: "address"
          },
          {
            internalType: "bytes[]",
            name: "data",
            type: "bytes[]"
          },
          {
            internalType: "bool",
            name: "reverseRecord",
            type: "bool"
          }
        ],
        internalType: "struct RegistrarController.RegisterRequest",
        name: "request",
        type: "tuple"
      }],
    name: "register",
    outputs: Core__Array.make(0, undefined),
    stateMutability: "payable",
    type: "function"
  },
  renew: {
    inputs: [
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "duration",
        type: "uint256"
      }
    ],
    name: "renew",
    outputs: Core__Array.make(0, undefined),
    stateMutability: "payable",
    type: "function"
  }
};

async function recordExists(name) {
  var domain = name + "." + Constants.sld;
  var node = Ens.namehash(domain);
  console.log("domain: \"" + domain + "\", node: \"" + node + "\"");
  return await OnChainOperationsCommon.publicClient.readContract({
              address: registryContract.address,
              abi: registryContract.abi,
              functionName: "recordExists",
              args: [node]
            });
}

async function available(name) {
  return await OnChainOperationsCommon.publicClient.readContract({
              address: controllerContract.address,
              abi: controllerContract.abi,
              functionName: "available",
              args: [name]
            });
}

async function registerPrice(name, duration) {
  var args = [
    name,
    duration
  ];
  return BigInt(await OnChainOperationsCommon.publicClient.readContract({
                  address: controllerContract.address,
                  abi: controllerContract.abi,
                  functionName: "registerPrice",
                  args: args
                }));
}

async function rentPrice(name, duration) {
  var args = [
    name,
    duration
  ];
  return await OnChainOperationsCommon.publicClient.readContract({
              address: controllerContract.address,
              abi: controllerContract.abi,
              functionName: "rentPrice",
              args: args
            });
}

async function name(address) {
  var node = Viem.keccak256(Viem.encodePacked([
            "bytes32",
            "bytes32"
          ], [
            "0x8b4150cc3554db98a2f60cb8c5a4cc48659d17a536ff9fe540be66d3307ee7a7",
            OnChainOperationsCommon.sha3HexAddress(address)
          ]));
  return await OnChainOperationsCommon.publicClient.readContract({
              address: resolverContract.address,
              abi: resolverContract.abi,
              functionName: "name",
              args: [node]
            });
}

async function multicallWithNodeCheck(walletClient, name, calls) {
  var node = Ens.namehash(name + "." + Constants.sld);
  var currentAddress = await OnChainOperationsCommon.currentAddress(walletClient);
  var match = await OnChainOperationsCommon.publicClient.simulateContract({
        account: currentAddress,
        address: resolverContract.address,
        abi: resolverContract.abi,
        functionName: "multicallWithNodeCheck",
        args: [
          node,
          calls
        ]
      });
  var hash = await walletClient.writeContract(match.request);
  var match$1 = await OnChainOperationsCommon.publicClient.waitForTransactionReceipt({
        hash: hash
      });
  console.log(hash + " confirmed in block " + match$1.blockNumber.toString() + ", status: " + match$1.status);
}

function encodeSetText(name, key, value) {
  var node = Ens.namehash(name + "." + Constants.sld);
  var abi = [{
      type: "function",
      name: "setText",
      inputs: [
        {
          name: "node",
          type: "bytes32"
        },
        {
          name: "key",
          type: "string"
        },
        {
          name: "value",
          type: "string"
        }
      ],
      outputs: [],
      stateMutability: "view"
    }];
  return Viem.encodeFunctionData({
              abi: abi,
              functionName: "setText",
              args: [
                node,
                key,
                value
              ]
            });
}

async function nameExpires(name) {
  var tokenId = BigInt(Viem.keccak256(name));
  var result = await OnChainOperationsCommon.publicClient.readContract({
        address: baseRegistrarContract.address,
        abi: baseRegistrarContract.abi,
        functionName: "nameExpires",
        args: [tokenId]
      });
  return Core__BigInt.toInt(result);
}

async function owner(name) {
  var domain = name + "." + Constants.sld;
  var node = Ens.namehash(domain);
  return await OnChainOperationsCommon.publicClient.readContract({
              address: registryContract.address,
              abi: registryContract.abi,
              functionName: "owner",
              args: [node]
            });
}

function encodeSetAddr(name, owner) {
  var node = Ens.namehash(name + "." + Constants.sld);
  var abi = [{
      type: "function",
      name: "setAddr",
      inputs: [
        {
          name: "node",
          type: "bytes32"
        },
        {
          name: "addr",
          type: "address"
        }
      ],
      outputs: [],
      stateMutability: "view"
    }];
  return Viem.encodeFunctionData({
              abi: abi,
              functionName: "setAddr",
              args: [
                node,
                owner
              ]
            });
}

function encodeSetName(name) {
  var abi = [{
      type: "function",
      name: "setName",
      inputs: [{
          name: "name",
          type: "string"
        }],
      outputs: [],
      stateMutability: "view"
    }];
  return Viem.encodeFunctionData({
              abi: abi,
              functionName: "setName",
              args: [name]
            });
}

async function register(walletClient, name, years, owner, onStatusChange) {
  console.log("Registering " + name);
  onStatusChange("Simulating");
  var duration = Math.imul(years, 31536000);
  var currentAddress = await OnChainOperationsCommon.currentAddress(walletClient);
  var resolvedAddress = Core__Option.getOr(owner, currentAddress);
  var setAddrData = encodeSetAddr(name, resolvedAddress);
  var priceInWei = await registerPrice(name, duration);
  var match = await OnChainOperationsCommon.publicClient.simulateContract({
        account: currentAddress,
        address: controllerContract.address,
        abi: [controllerContract.register],
        functionName: "register",
        args: [{
            name: name,
            owner: resolvedAddress,
            duration: duration,
            resolver: Constants.resolverContractAddress,
            data: [setAddrData],
            reverseRecord: true
          }],
        value: priceInWei
      });
  onStatusChange("WaitingForSignature");
  var hash = await walletClient.writeContract(match.request);
  onStatusChange("Broadcasting");
  await OnChainOperationsCommon.publicClient.waitForTransactionReceipt({
        hash: hash
      });
  return onStatusChange("Confirmed");
}

async function renew(walletClient, name, years) {
  var duration = Math.imul(years, 31536000);
  var currentAddress = await OnChainOperationsCommon.currentAddress(walletClient);
  var priceInWei = await rentPrice(name, duration);
  var match = await OnChainOperationsCommon.publicClient.simulateContract({
        account: currentAddress,
        address: controllerContract.address,
        abi: [controllerContract.renew],
        functionName: "renew",
        args: [
          name,
          duration
        ],
        value: priceInWei
      });
  var hash = await walletClient.writeContract(match.request);
  var match$1 = await OnChainOperationsCommon.publicClient.waitForTransactionReceipt({
        hash: hash
      });
  console.log(hash + " confirmed in block " + match$1.blockNumber.toString() + ", status: " + match$1.status);
}

async function setAddr(walletClient, name, a) {
  var domain = name + "." + Constants.sld;
  var node = Ens.namehash(domain);
  var address = Viem.getAddress(a);
  var currentAddr = await OnChainOperationsCommon.currentAddress(walletClient);
  var match = await OnChainOperationsCommon.publicClient.simulateContract({
        account: currentAddr,
        address: Constants.resolverContractAddress,
        abi: [{
            type: "function",
            name: "setAddr",
            inputs: [
              {
                name: "node",
                type: "bytes32"
              },
              {
                name: "a",
                type: "address"
              }
            ],
            outputs: [],
            stateMutability: "nonpayable"
          }],
        functionName: "setAddr",
        args: [
          node,
          address
        ]
      });
  var hash = await walletClient.writeContract(match.request);
  var match$1 = await OnChainOperationsCommon.publicClient.waitForTransactionReceipt({
        hash: hash
      });
  console.log("setAddr confirmed in block " + match$1.blockNumber.toString() + ", status: " + match$1.status);
}

async function reclaim(walletClient, tokenId, newOwner) {
  var currentAddress = await OnChainOperationsCommon.currentAddress(walletClient);
  var match = await OnChainOperationsCommon.publicClient.simulateContract({
        account: currentAddress,
        address: Constants.baseRegistrarContractAddress,
        abi: [{
            type: "function",
            name: "reclaim",
            inputs: [
              {
                name: "id",
                type: "uint256"
              },
              {
                name: "owner",
                type: "address"
              }
            ],
            outputs: [],
            stateMutability: "nonpayable"
          }],
        functionName: "reclaim",
        args: [
          tokenId,
          newOwner
        ]
      });
  var hash = await walletClient.writeContract(match.request);
  var match$1 = await OnChainOperationsCommon.publicClient.waitForTransactionReceipt({
        hash: hash
      });
  console.log(hash + " confirmed in block " + match$1.blockNumber.toString() + ", status: " + match$1.status);
}

async function setName(walletClient, name) {
  var currentAddress = await OnChainOperationsCommon.currentAddress(walletClient);
  var hash = await walletClient.writeContract({
        address: Constants.reverseRegistrarContractAddress,
        abi: [{
            type: "function",
            name: "setName",
            inputs: [{
                name: "name",
                type: "string"
              }],
            outputs: [],
            stateMutability: "nonpayable"
          }],
        functionName: "setName",
        account: currentAddress,
        args: [name]
      });
  var match = await OnChainOperationsCommon.publicClient.waitForTransactionReceipt({
        hash: hash
      });
  console.log("setName confirmed in block " + match.blockNumber.toString() + ", status: " + match.status);
}

async function safeTransferFrom(walletClient, from, to, tokenId) {
  var match = await OnChainOperationsCommon.publicClient.simulateContract({
        account: from,
        address: Constants.baseRegistrarContractAddress,
        abi: [{
            type: "function",
            name: "safeTransferFrom",
            inputs: [
              {
                name: "from",
                type: "address"
              },
              {
                name: "to",
                type: "address"
              },
              {
                name: "tokenId",
                type: "uint256"
              }
            ],
            outputs: [],
            stateMutability: "payable"
          }],
        functionName: "safeTransferFrom",
        args: [
          from,
          to,
          tokenId
        ]
      });
  var hash = await walletClient.writeContract(match.request);
  var match$1 = await OnChainOperationsCommon.publicClient.waitForTransactionReceipt({
        hash: hash
      });
  console.log("transfer confirmed in block " + match$1.blockNumber.toString() + ", status: " + match$1.status);
}

async function transferSubname(walletClient, name, newOwner) {
  console.log("Transferring " + name + " to " + newOwner);
  var currentAddress = await OnChainOperationsCommon.currentAddress(walletClient);
  var tokenId = BigInt(Viem.keccak256(name));
  return await safeTransferFrom(walletClient, currentAddress, Viem.getAddress(newOwner), tokenId);
}

async function getText(name, key) {
  var node = Ens.namehash(name + "." + Constants.sld);
  var result = await OnChainOperationsCommon.publicClient.readContract({
        address: resolverContract.address,
        abi: [{
            type: "function",
            name: "text",
            inputs: [
              {
                name: "node",
                type: "bytes32"
              },
              {
                name: "key",
                type: "string"
              }
            ],
            outputs: [{
                name: "",
                type: "string"
              }],
            stateMutability: "view"
          }],
        functionName: "text",
        args: [
          node,
          key
        ]
      });
  if (result === "") {
    return ;
  } else {
    return Caml_option.some(result);
  }
}

export {
  baseRegistrarContract ,
  resolverContract ,
  registryContract ,
  controllerContract ,
  recordExists ,
  available ,
  registerPrice ,
  rentPrice ,
  name ,
  multicallWithNodeCheck ,
  encodeSetText ,
  nameExpires ,
  owner ,
  encodeSetAddr ,
  encodeSetName ,
  register ,
  renew ,
  setAddr ,
  reclaim ,
  setName ,
  safeTransferFrom ,
  transferSubname ,
  getText ,
}
/* controllerContract Not a pure module */
