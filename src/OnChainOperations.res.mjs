// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Viem from "viem";
import * as Ens from "viem/ens";
import * as Constants from "./Constants.res.mjs";
import Sha3Mjs from "./sha3.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Chains from "viem/chains";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

var baseRegistrarContract = {
  address: Constants.baseRegistrarContractAddress,
  abi: [{
      type: "function",
      name: "nameExpires",
      inputs: [{
          name: "id",
          type: "uint256"
        }],
      outputs: [{
          name: "expiry",
          type: "uint256"
        }],
      stateMutability: "view"
    }]
};

var resolverContract = {
  address: Constants.resolverContractAddress,
  abi: [{
      inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }],
      name: "name",
      outputs: [{
          internalType: "string",
          name: "",
          type: "string"
        }],
      stateMutability: "view",
      type: "function"
    }]
};

var registryContract = {
  address: Constants.registryContractAddress,
  abi: [
    {
      type: "function",
      name: "recordExists",
      inputs: [{
          name: "node",
          type: "bytes32"
        }],
      outputs: [{
          name: "",
          type: "bool"
        }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "owner",
      inputs: [{
          name: "node",
          type: "bytes32"
        }],
      outputs: [{
          name: "",
          type: "address"
        }],
      stateMutability: "view"
    }
  ]
};

var controllerContract = {
  address: Constants.controllerContractAddress,
  abi: [
    {
      type: "function",
      name: "available",
      inputs: [{
          name: "name",
          type: "string"
        }],
      outputs: [{
          name: "",
          type: "bool"
        }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "registerPrice",
      inputs: [
        {
          name: "name",
          type: "string"
        },
        {
          name: "duration",
          type: "uint256"
        }
      ],
      outputs: [{
          name: "",
          type: "uint256"
        }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "renew",
      inputs: [
        {
          name: "name",
          type: "string"
        },
        {
          name: "duration",
          type: "uint256"
        }
      ],
      outputs: [],
      stateMutability: "payable"
    }
  ],
  abiForWrite: [{
      inputs: [{
          components: [
            {
              internalType: "string",
              name: "name",
              type: "string"
            },
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "duration",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "resolver",
              type: "address"
            },
            {
              internalType: "bytes[]",
              name: "data",
              type: "bytes[]"
            },
            {
              internalType: "bool",
              name: "reverseRecord",
              type: "bool"
            }
          ],
          internalType: "struct RegistrarController.RegisterRequest",
          name: "request",
          type: "tuple"
        }],
      name: "register",
      outputs: Core__Array.make(0, undefined),
      stateMutability: "payable",
      type: "function"
    }]
};

var client = Viem.createPublicClient({
      chain: Chains.koi,
      transport: Viem.http(Constants.rpcUrl)
    });

async function recordExists(name) {
  var domain = name + "." + Constants.sld;
  var node = Ens.namehash(domain);
  console.log("domain: \"" + domain + "\", node: \"" + node + "\"");
  return await client.readContract({
              address: registryContract.address,
              abi: registryContract.abi,
              functionName: "recordExists",
              args: [node]
            });
}

async function available(name) {
  return await client.readContract({
              address: controllerContract.address,
              abi: controllerContract.abi,
              functionName: "available",
              args: [name]
            });
}

async function registerPrice(name, duration) {
  var args = [
    name,
    duration
  ];
  return BigInt(await client.readContract({
                  address: controllerContract.address,
                  abi: controllerContract.abi,
                  functionName: "registerPrice",
                  args: args
                }));
}

function sha3HexAddress(prim) {
  return Sha3Mjs(prim);
}

async function name(address) {
  var node = Viem.keccak256(Viem.encodePacked([
            "bytes32",
            "bytes32"
          ], [
            "0x32347c1de91cbc71535aee17456bbe8987cc116a2782950e2697c6fc411ba53f",
            Sha3Mjs(address)
          ]));
  return await client.readContract({
              address: resolverContract.address,
              abi: resolverContract.abi,
              functionName: "name",
              args: [node]
            });
}

async function nameExpires(name) {
  var tokenId = BigInt(Viem.keccak256(name));
  return await client.readContract({
              address: baseRegistrarContract.address,
              abi: baseRegistrarContract.abi,
              functionName: "nameExpires",
              args: [tokenId]
            });
}

async function owner(name) {
  var domain = name + "." + Constants.sld;
  var node = Ens.namehash(domain);
  return await client.readContract({
              address: registryContract.address,
              abi: registryContract.abi,
              functionName: "owner",
              args: [node]
            });
}

var publicClient = Viem.createPublicClient({
      chain: Chains.koi,
      transport: Viem.http(Constants.rpcUrl)
    });

function buildWalletClient() {
  var ethereum = window.ethereum;
  if (ethereum !== undefined) {
    return Caml_option.some(Viem.createWalletClient({
                    chain: Chains.koi,
                    transport: Viem.custom(Caml_option.valFromOption(ethereum))
                  }));
  }
  
}

async function currentAddress(walletClient) {
  var result = await walletClient.requestAddresses();
  if (result.length < 1) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "OnChainOperations.res",
            295,
            2
          ],
          Error: new Error()
        };
  }
  return result[0];
}

function encodeSetAddr(name, owner) {
  var node = Ens.namehash(name + "." + Constants.sld);
  var abi = [{
      type: "function",
      name: "setAddr",
      inputs: [
        {
          name: "node",
          type: "bytes32"
        },
        {
          name: "addr",
          type: "address"
        }
      ],
      outputs: [],
      stateMutability: "view"
    }];
  return Viem.encodeFunctionData({
              abi: abi,
              functionName: "setAddr",
              args: [
                node,
                owner
              ]
            });
}

async function register(walletClient, name, years, owner, onStatusChange) {
  onStatusChange("Simulating");
  var duration = Math.imul(years, 31536000);
  var currentAddress$1 = await currentAddress(walletClient);
  var resolvedAddress = Core__Option.getOr(owner, currentAddress$1);
  var setAddrData = encodeSetAddr(name, resolvedAddress);
  var priceInWei = await registerPrice(name, duration);
  var match = await publicClient.simulateContract({
        account: currentAddress$1,
        address: controllerContract.address,
        abi: controllerContract.abiForWrite,
        functionName: "register",
        args: [{
            name: name,
            owner: resolvedAddress,
            duration: duration,
            resolver: Constants.resolverContractAddress,
            data: [setAddrData],
            reverseRecord: true
          }],
        value: priceInWei
      });
  onStatusChange("WaitingForSignature");
  var hash = await walletClient.writeContract(match.request);
  onStatusChange("Broadcasting");
  await publicClient.waitForTransactionReceipt({
        hash: hash
      });
  return onStatusChange("Confirmed");
}

export {
  baseRegistrarContract ,
  resolverContract ,
  registryContract ,
  controllerContract ,
  client ,
  recordExists ,
  available ,
  registerPrice ,
  sha3HexAddress ,
  name ,
  nameExpires ,
  owner ,
  publicClient ,
  buildWalletClient ,
  currentAddress ,
  encodeSetAddr ,
  register ,
}
/* controllerContract Not a pure module */
