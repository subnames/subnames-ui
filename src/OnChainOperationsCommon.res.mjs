// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Viem from "viem";
import * as Constants from "./Constants.res.mjs";
import Sha3Mjs from "./sha3.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Chains from "viem/chains";

async function waitForTransactionReceiptWithRetry(publicClient, hash, maxRetriesOpt, delayMsOpt) {
  var maxRetries = maxRetriesOpt !== undefined ? maxRetriesOpt : 10;
  var delayMs = delayMsOpt !== undefined ? delayMsOpt : 2000;
  var attempt = async function (retryCount) {
    try {
      console.log("Waiting for transaction receipt: " + hash + ", attempt " + retryCount.toString() + "/" + maxRetries.toString());
      var receipt = await publicClient.waitForTransactionReceipt({
            hash: hash
          });
      console.log("Transaction " + hash + " confirmed in block " + receipt.blockNumber.toString() + ", status: " + receipt.status);
      return receipt;
    }
    catch (exn){
      if (retryCount < maxRetries) {
        console.log("Receipt not found yet, retrying in " + delayMs.toString() + "ms...");
        await new Promise((function (resolve, param) {
                setTimeout((function () {
                        resolve();
                      }), delayMs);
              }));
        return await attempt(retryCount + 1 | 0);
      } else {
        console.log("Max retries reached for transaction " + hash + ". The transaction may still succeed on-chain.");
        return {
                blockNumber: BigInt(0),
                status: "success_assumed"
              };
      }
    }
  };
  return await attempt(1);
}

function sha3HexAddress(prim) {
  return Sha3Mjs(prim);
}

var publicClient = Viem.createPublicClient({
      chain: Chains.darwinia,
      transport: Viem.http(Constants.rpcUrl)
    });

function buildWalletClient() {
  var ethereum = window.ethereum;
  if (ethereum !== undefined) {
    return Caml_option.some(Viem.createWalletClient({
                    chain: Chains.darwinia,
                    transport: Viem.custom(Caml_option.valFromOption(ethereum))
                  }));
  }
  
}

async function currentAddress(walletClient) {
  var result = await walletClient.requestAddresses();
  if (result.length < 1) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "OnChainOperationsCommon.res",
            90,
            2
          ],
          Error: new Error()
        };
  }
  return result[0];
}

async function getCurrentAddress() {
  var walletClient = buildWalletClient();
  if (walletClient !== undefined) {
    return await currentAddress(Caml_option.valFromOption(walletClient));
  }
  
}

export {
  waitForTransactionReceiptWithRetry ,
  sha3HexAddress ,
  publicClient ,
  buildWalletClient ,
  currentAddress ,
  getCurrentAddress ,
}
/* publicClient Not a pure module */
